<?php

namespace Apricot\Component\Cache;

trait FilesystemCache
{
    private static $cacheMap;

    public static function cacheWithFile($key, $value = null, $expire = 3600, $forceOverride = false)
    {
        $map = self::getCacheMap();

        if (array_key_exists($key, $map)) {

            $isStale = $map[$key]['expire'] < mktime();

            if (null !== $value && ($forceOverride || $isStale)) {
                $map[$key] = array('value' => $value, 'expire' => mktime()+$expire);
            } else {
                return $map[$key];
            }
        } else {
            $map[$key] = array('value' => $value, 'expire' => mktime()+$expire);
        }

        self::writeCacheMap($map);
    }

    public static function purgeCacheFile()
    {
        unlink(self::getCacheFile());
    }

    protected static function writeCacheMap(array $map)
    {
        $headContent = <<<EOF
<?php

/**
 * Cache file generated by Apricot
 */

EOF;
        file_put_contents(self::getCacheFile(), $headContent . "return " . var_export($map, true) .";\n");
    }

    protected static function getCacheMap()
    {
        if (null == self::$cacheMap) {
            self::$cacheMap = require self::getCacheFile();
        }
        
        return self::$cacheMap;
    }

    protected static function getCacheFile()
    {
        $cacheFile = self::cacheDir() . '/cache_map.php';

        if (!file_exists($cacheFile)) {
            if (!opendir(self::cacheDir())) {
                mkdir(self::cacheDir());
            }
            file_put_contents($cacheFile, "<?php\n\nreturn array();\n");
        }

        return $cacheFile;
    }
}
